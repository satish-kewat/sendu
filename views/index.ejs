<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P File Sharing</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- QRCode library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        .small-btn { margin-left:8px; padding:6px 8px; font-size:13px; }
        #connStatus { margin-left:10px; font-weight:600; }
        #qrcode { display:none; margin-top:10px; }
        pre.sdp-fallback { white-space: pre-wrap; word-break:break-all; font-size:12px; background:#f9f9f9; padding:8px; border-radius:4px; max-height:220px; overflow:auto; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center">P2P File Sharing</h1>
        <form id="form">
            <div class="form-group container">
                <label for="files">Upload Files</label>
                <input class="form-control" type="file" name="" id="upload-input" required>
                </br>
                <div class="progress">
                    <div class="progress-bar progress-bar-success progress-bar-striped" style=" width:0%;"></div>
                </div>

                <div class="form-group container" style="margin-top:10px;">
                    <button id="button" class="btn btn-success">Share File</button>

                    <!-- Small P2P control buttons (added minimally) -->
                    <button id="createConn" type="button" class="btn btn-info small-btn">Create Connection</button>
                    <button id="startResponder" type="button" class="btn btn-warning small-btn">I scanned an Offer</button>
                    <span id="connStatus">Not connected</span>
                </div>
        </form>

        <br /><br />
        <h1 style="display: none;" id="result">File is Uploaded / Received. Now you can share Link </h1>
        <br><br>
        <div id="section" style="display: none;">
            <input onclick="copy()" class="input-copy" value="" id="url" readonly />
            <button class="copy-btn" id="copyBtn" onclick="copy()"><i class="fa-regular fa-copy"></i></button>

            <!-- QR code will appear here -->
            <div id="qrcode"></div>
            <div id="downloadLink" style="margin-top:8px;"></div>
            <div id="sdpFallback" style="margin-top:8px;"></div>
        </div>
        <div id="copied-success"  style="display: none;" class="copied">
            <span>Copied</span>
        </div>
    </div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script>
/*
  Token-based signaling client:
  - Posts full SDP to server /signal and gets a short token.
  - QR shows '?t=TOKEN' (short).
  - Receiver fetches SDP via /signal/:token, creates answer, posts answer and shows answer token.
  - Initiator fetches answer token and applies answer.
  - Afterwards DataChannel used to send file.
*/

let files = [];
let pc = null;
let dc = null;
let isInitiator = false;
const pcConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
const CHUNK_SIZE = 64 * 1024; // 64KB

// UI refs
const connStatus = document.getElementById('connStatus');
function setConnStatus(s) { connStatus.innerText = s; }

// QR helper
function makeQR(text) {
    try {
        $("#qrcode").empty();
        $("#sdpFallback").empty && $("#sdpFallback").empty();
        new QRCode(document.getElementById("qrcode"), {
            text: text,
            width: 200,
            height: 200,
            correctLevel: QRCode.CorrectLevel.H
        });
        $("#qrcode").show();
        $("#section").show();
    } catch (e) {
        console.error("QR generation failed:", e);
        $("#qrcode").hide();
        if ($("#sdpFallback").length) {
            $("#sdpFallback").html('<label>SDP (fallback):</label><pre class="sdp-fallback"></pre>');
            $("#sdpFallback pre").text(text);
            $("#section").show();
        }
    }
}
function clearQR() { $("#qrcode").empty().hide(); $("#sdpFallback").empty && $("#sdpFallback").empty(); }

// ---------------- SIGNALING HELPERS (use server /signal) ----------------
async function postSdpGetToken(sdp) {
  const resp = await fetch('/signal', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ sdp })
  });
  if (!resp.ok) throw new Error('signal-post-failed: ' + resp.status);
  const j = await resp.json();
  return j.token;
}

async function fetchSdpByToken(token) {
  const resp = await fetch('/signal/' + encodeURIComponent(token));
  if (!resp.ok) throw new Error('signal-get-failed: ' + resp.status);
  const j = await resp.json();
  return j.sdp;
}
// ---------------------------------------------------------------------

// ensure peer connection
async function ensurePC() {
    if (pc) return pc;
    pc = new RTCPeerConnection(pcConfig);
    pc.oniceconnectionstatechange = () => {
        console.log('ICE state', pc.iceConnectionState);
        setConnStatus('ICE: ' + pc.iceConnectionState);
    };
    pc.onicecandidate = e => { console.log('icecandidate', !!e.candidate); };
    pc.ondatachannel = e => {
        console.log('got datachannel', e.channel.label);
        dc = e.channel;
        setupDC();
    };
    return pc;
}

function setupDC() {
    if (!dc) return;
    dc.binaryType = 'arraybuffer';
    dc.onopen = () => { setConnStatus('Connected (datachannel open)'); console.log('dc open'); };
    dc.onclose = () => { setConnStatus('DataChannel closed'); console.log('dc closed'); };
    dc.onmessage = onDCMessage;
}

// wait for ICE gathering complete
function waitForIceGatheringComplete(pcInstance, timeout = 5000) {
    return new Promise((resolve) => {
        if (!pcInstance) return resolve();
        if (pcInstance.iceGatheringState === 'complete') return resolve();
        const onState = () => {
            if (pcInstance.iceGatheringState === 'complete') { cleanup(); resolve(); }
        };
        const cleanup = () => {
            pcInstance.removeEventListener('icegatheringstatechange', onState);
            clearTimeout(tid);
        };
        pcInstance.addEventListener('icegatheringstatechange', onState);
        const tid = setTimeout(() => { cleanup(); resolve(); }, timeout);
    });
}

// DataChannel incoming handling
let incomingMeta = null, incomingBuffers = [], incomingReceived = 0;
function onDCMessage(evt) {
    if (typeof evt.data === 'string') {
        try {
            const m = JSON.parse(evt.data);
            if (m.type === 'meta') {
                incomingMeta = m;
                incomingBuffers = [];
                incomingReceived = 0;
                console.log('incoming meta', m);
                $(".progress-bar").css("width", "0%").text("0%");
            }
        } catch (e) { console.warn('text message', evt.data); }
    } else if (evt.data instanceof ArrayBuffer) {
        incomingBuffers.push(evt.data);
        incomingReceived += evt.data.byteLength;
        const total = incomingMeta ? incomingMeta.size : 0;
        if (total) {
            const percent = Math.round((incomingReceived / total) * 100);
            $(".progress-bar").css("width", percent + "%").text(percent + "%");
        } else {
            $(".progress-bar").css("width", "50%").text(`${incomingReceived} bytes`);
        }
        if (incomingMeta && incomingReceived >= incomingMeta.size) {
            const blob = new Blob(incomingBuffers, { type: incomingMeta.fileType || 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            $("#result").show();
            $("#section").show();
            $(".input-copy").val(url);
            $("#downloadLink").html(`<a href="${url}" download="${incomingMeta.name}" class="btn btn-primary">Download ${incomingMeta.name}</a>`);
            makeQR(url);
            $(".progress-bar").css("width", "100%").text("Received");
            incomingMeta = null; incomingBuffers = []; incomingReceived = 0;
            console.log('file received');
        }
    }
}

// Create Offer (initiator) - POST offer SDP to server and show short token QR
document.getElementById('createConn').addEventListener('click', async () => {
    try {
        isInitiator = true;
        setConnStatus('Creating offer...');
        await ensurePC();

        // create datachannel as sender side
        dc = pc.createDataChannel('filetransfer');
        setupDC();

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        // wait for ICE candidates to be gathered (reliable SDP)
        await waitForIceGatheringComplete(pc, 5000);

        const sdpToSend = pc.localDescription.sdp;

        // === POST full SDP to server and get short token ===
        const token = await postSdpGetToken(sdpToSend);
        const url = location.origin + location.pathname + '?t=' + token; // small token in QR

        makeQR(url);
        alert('Offer QR (token) created — scan it from other device (or copy URL).');
        setConnStatus('Offer token created; waiting for answer token (scan answer into this page).');
        console.log('Offer SDP length:', sdpToSend.length);
    } catch (err) {
        console.error('Error creating offer:', err);
        alert('Error creating offer — see console for details.');
        setConnStatus('Error creating offer');
    }
});

// Responder helper (UI button)
document.getElementById('startResponder').addEventListener('click', () => {
    setConnStatus('Responder mode — open scanned offer URL on this device.');
    alert('Open the scanned URL (from initiator QR) on this device — the page will auto-create answer and show QR.');
});

// handle token param on load: ?t=TOKEN
(async function handleParamsOnLoad() {
    try {
        const params = new URLSearchParams(location.search);

        if (params.has('t')) {
            const token = params.get('t');
            setConnStatus('Fetching SDP token from server...');
            // fetch the SDP stored on server (this deletes token on server)
            const remoteSdp = await fetchSdpByToken(token);

            // If pc not created -> treat incoming SDP as OFFER (responder)
            if (!pc) {
                setConnStatus('Handling incoming offer (token)...');
                await ensurePC();
                await pc.setRemoteDescription({ type: 'offer', sdp: remoteSdp });

                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                await waitForIceGatheringComplete(pc, 5000);

                // Post answer SDP and show a short token QR for initiator to fetch
                const answerToken = await postSdpGetToken(pc.localDescription.sdp);
                const url = location.origin + location.pathname + '?t=' + answerToken;
                makeQR(url);
                setConnStatus('Answer token created. Show this QR to initiator.');
                alert('Answer QR (token) created — scan it from initiator device to complete connection.');
            } else {
                // pc exists -> treat as ANSWER for initiator
                setConnStatus('Applying answer (token)...');
                await pc.setRemoteDescription({ type: 'answer', sdp: remoteSdp });
                setConnStatus('Answer applied. Waiting for datachannel to open.');
                clearQR();
                console.log('Answer applied (from token).');
            }
        } else {
            console.log('No token in URL');
        }
    } catch (err) {
        console.error('Error handling token on load:', err);
        alert('Signaling error — see console.');
    }
})();

// send file over DataChannel (called after dc is open)
async function sendFileOverDataChannel(file) {
    if (!dc || dc.readyState !== 'open') {
        alert('DataChannel not open. Please wait until connection is established.');
        return;
    }
    // send metadata
    const meta = { type: 'meta', name: file.name, size: file.size, fileType: file.type };
    dc.send(JSON.stringify(meta));

    let offset = 0;
    const size = file.size;

    function readSlice(o) {
        return new Promise((resolve, reject) => {
            const slice = file.slice(o, Math.min(o + CHUNK_SIZE, size));
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = err => reject(err);
            reader.readAsArrayBuffer(slice);
        });
    }

    while (offset < size) {
        const arrayBuffer = await readSlice(offset);
        dc.send(arrayBuffer);
        offset += arrayBuffer.byteLength;
        const percent = Math.round((offset / size) * 100);
        $(".progress-bar").css("width", percent + "%").text(percent + "%");
        // backpressure: small wait if bufferedAmount high
        if (dc.bufferedAmount > 16 * CHUNK_SIZE) await new Promise(r => setTimeout(r, 200));
    }

    $(".progress-bar").css("width", "100%").text("Sent");
    alert('File sent over P2P.');
}

// form submit - require P2P connection first
$("#form").submit(function (event) {
    event.preventDefault();

    $(".progress-bar").text("0%");
    $("#button").text("Sending File...");
    $("#button").prop("disabled", true);
    $(".progress-bar").width("0%");

    convertFileP2P();
});

$("#upload-input").change(function () {
    files = $(this).get(0).files;
    console.log(files);
});

async function convertFileP2P() {
    if (!files || files.length === 0) {
        alert('Please choose a file first.');
        $("#button").text("Share File");
        $("#button").prop("disabled", false);
        return;
    }

    // Enforce P2P-first: require datachannel open
    if (!dc || dc.readyState !== 'open') {
        $("#button").text("Share File");
        $("#button").prop("disabled", false);
        // show clear instruction to create connection first
        const ok = confirm('No P2P connection is established. Do you want instructions to create connection now? (Press OK to see instructions)');
        if (ok) {
            alert('1) Click "Create Connection" on the sender device.\n2) Scan the displayed Offer QR on the receiving device (open resulting page there).\n3) The receiving device will show an Answer QR — scan that back on the sender. \n4) Wait until status shows "Connected (datachannel open)".\n5) Then click "Share File" again.');
        }
        // optional fallback (commented on purpose)
        // uploadToServer(files);
        return;
    }

    // datachannel is open -> send via P2P
    try {
        await sendFileOverDataChannel(files[0]);
        $("#button").text("Share File");
        $("#button").prop("disabled", false);
        $("#upload-input").val("");
        $("#result").show();
        $(".input-copy").val("Sent via P2P to connected peer");
        $("#section").show();
        clearQR();
    } catch (err) {
        console.error('p2p send error', err);
        alert('P2P send failed — see console.');
        $("#button").text("Share File");
        $("#button").prop("disabled", false);
    }
}

// Optional existing AJAX upload kept for future use (not used now)
function uploadToServer(filesParam) {
    let formData = new FormData();
    for (let i = 0; i < filesParam.length; i++) {
        let file = filesParam[i];
        formData.append("file", file, file.name);
    }
    $.ajax({
        url: "/uploadfile",
        type: "POST",
        data: formData,
        processData: false,
        contentType: false,
        success: function (data) {
            console.log(data);
            $("#button").text("Share Files");
            $("#button").prop("disabled", false);
            $("#upload-input").val("");
            $(".progress-bar").width("0%");
            $("#result").show();
            const fileUrl = location.origin + "/files/" + data.path;
            $(".input-copy").val(fileUrl);
            $("#section").show();
            makeQR(fileUrl);
        },
        xhr: function () {
            let xhr = new XMLHttpRequest();
            xhr.upload.addEventListener("progress", function (evt) {
                if (evt.lengthComputable) {
                    let percentComplete = Math.round((evt.loaded / evt.total) * 100);
                    $(".progress-bar").css("width", percentComplete + "%");
                    $(".progress-bar").text(percentComplete + "%");
                    if (percentComplete === 100) { $(".progress-bar").text("Done"); }
                }
            }, false);
            return xhr;
        },
    });
}

function copy() {
    let copyText = (document.getElementById("url"));
    copyText.select();
    copyText.setSelectionRange(0, 99999);
    document.execCommand("copy");
    $("#copied-success").fadeIn(800);
    $("#copied-success").fadeOut(800);
}
</script>
</body>
</html>
